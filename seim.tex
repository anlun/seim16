%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************
\documentclass[conference]{IEEEtran}
\input{preamble}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{verbments}
\usepackage{minted}
\usepackage{caption}
\usepackage{fancybox}
%% \usepackage{cite}
\newfontfamily{\cyrillicfonttt}{DejaVu Serif}

\makeatletter
\define@key{blx@lbx}{fromjapanese}{\blx@defstring{fromjapanese}{#1}}
\define@key{blx@lbx}{langjapanese}{\blx@defstring{langjapanese}{#1}}
\makeatother

\lstset{
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=~,
language=java
}

%% Bibliography file
%% \addbibresource{seim.bib}


% If you need to correct hyphenations, add them here
%% \hyphenation{op-tical net-works semi-conduc-tor}

\newcommand{\igo}[1]{{\color{red}({Игорь:\ #1})}\marginpar{!}}
\newcommand{\app}[1]{{\color{blue}({Антон:\ #1})}\marginpar{!}}

\begin{document}
%
% paper title
%
% In English titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Генерация декларативных форматеров по грамматике в форме Бэкуса-Наура}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Игорь Озерных}
\IEEEauthorblockA{Санкт-Петербургский\\Государственный Университет\\
st011628@student.spbu.ru}
\and
\IEEEauthorblockN{Антон Подкопаев}
\IEEEauthorblockA{Санкт-Петербургский\\Государственный Университет\\
a.podkopaev@2009.spbu.ru}
}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
Одним из декларативных подходов к заданию средств форматирования кода (СФК)
является метод \emph{синтаксических шаблонов}, которые
являются примерами представления (форматирования) синтаксических
конструкций целевого языка.
Для извлечения шаблонов из предоставленного \emph{образца},
кодовой базы на целевом языке с желаемым стилем форматирования,
используется (не кооперативный) синтаксический анализатор. 

Недостатком существующей системы является то, что 
%% форматирования с использованием синтаксических шаблонов
для получения форматера нового целевого языка
необходимо вручную реализовать языкозависимую прослойку между ядром
системы и представлением синтаксического
дерева, получаемого в результате работы анализатора.
Этот процесс трудоёмок и требует глубоких знаний о системе.

%% Упомянутая прослойка достаточно велика и сложна, поскольку представление
%% дерева имеет размер (количество соответствующих ему классов),
%% пропорциональный числу конструкций целевого языка.
%% Кроме того, существующая система предполагает создание данной прослойки
%% вручную.

Данная работа посвящена автоматическому получению такой прослойки
для случая, когда синтаксический анализатор генерируется
из грамматики языка в
расширенной форме Бэкуса-Наура.
Реализация выполнена в виде расширения плагина Grammar-Kit
для среды разработки IntelliJ IDEA, позволяющего
по грамматике в форме Бэкуса-Наура получить и синтаксический анализатор,
и декларативное СФК для целевого языка.
В рамках апробации разработанная система была использована
для получения СФК по грамматике учебного языка While.
\end{abstract}

\section{Введение}
Автоматическое форматирование текстов программ является
классической задачей, возникающей в контексте различных 
языковых процессоров, например, сред разработки (IDE) и декомпиляторов.
Оно подразумевает построение текста программы по её синтаксическому
дереву --- обратное к синтаксическому анализу преобразование ---
или изменение существующего текста с сохранением его семантики.
Программный компонент, занимающийся форматированием, мы будем называть
\emph{форматер} (formatter).
Обычно предполагается, что результат работы форматера
соответствует некоторому
\emph{стандарту кодирования} (CK, coding convention), определяющему
как должны выглядеть те или иные синтаксические конструкции.
Например, СК для языка Java должен описывать, на которую
строчку ставить открывающую фигурную скобку тела класса: 
на ту же, где и имя класса, или на следующую.


%% Например, для языка программирования C++ популрнынаиболее популярными являются следующие стандарты кодирования: Google\footnote{\texttt{https://google-styleguide.googlecode.com/svn/trunk/cppguide.html}}, GNU\footnote{\texttt{http://www.gnu.org/prep/standards/standards.html}}, BSD\footnote{\texttt{https://www.freebsd.org/cgi/man.cgi?query=style\&sektion=9}}.


%% Одним из подходов к решению данной задачи является
%% \emph{декларативное форматирование}. Оно позволяет
%% определить форматер по множеству \emph{синтаксических шаблонов}, т.е.
%% примеров представления (форматирования) синтаксических конструкций.
%% Шаблоны, в свою очередь, могут быть извлечены
%% из некоторого образца --- кодовой базы с желаемым стилем форматирования
%% на целевом языке.

%% Для извлечения шаблонов используется кооперативный синтаксический анализатор
%% целевого языка.


%% Недостатком декларативных форматеров является относительная сложность их
%% реализации для новых целевых языков --- необходимо иметь кооперативный
%% синтаксический анализатор целевого языка.

%% Существуют реализации декларативных форматеров для Java и учебного
%% языка While.
%% Недостатком существующих декларативных форматеров является 

%% На этапе поддержки и сопровождения в жизненном цикле ПО особенно важным является понимание программного текста поддерживаемой системы. 
%% Для этого необходимо сделать код легко читаемым, то есть форматировать его.

Одними из самых используемых являются встроенные форматеры
сред разработки (IDE) --- IntelliJ IDEA, Eclipse, Visual Studio и т.д.
В них желаемый стиль кодирования задается с помощью множества настроек.
Например, уже упомянутое расположение открывающей фигурной скобки,
количество пробелов в отступе (для операторов внутри фигурных скобок),
наличие/отсутствие пробела перед арифметическим оператором.

Недостатком таких форматеров является необходимость вручную задавать
настройки форматирования, что может быть неудобным при переходе
от одного СК к другому.
Кроме того, количество принципиально разных стилей форматирования,
которые можно задать с помощью данных настроек, невелико и ограничено
представлениями разработчиков форматеров о возможных СК целевого языка.
Например, настройки форматеров для C++ упомянутых IDE не позволяют задавать
форматирование, подобное S-выражениям языка Lisp:
%выразить СК, в котором закрывающая фигурная скобка ставится на той же строке, что и последний оператор блока (см. рис.~\ref{fig:unusualCC}).

\lstinputlisting[language=c]{codes/unusualCC.txt}

Альтернативный подход к форматированию описан в статье [1] %~\cite{while}
и основывается на сопоставлении с образцом и синтаксических шаблонах.
Под \emph{шаблоном} понимаются данные, сопоставление которых с элементом синтаксического дерева дает текстовое представление этого элемента.
Например, к синтаксическому дереву оператора ветвления
\vspace{.3cm}

{
\centering
\includegraphics[width=.5\textwidth]{images/ifTree.jpg}
}

\vspace{-.5cm}
\noindent
может быть применён шаблон форматирования с рис.~\ref{fig:tmpltcodeintro}а,
в результате чего получается текст с рис.~\ref{fig:tmpltcodeintro}б.

\fvset{frame=lines,framesep=6pt}
\begin{figure}[ht]
\noindent\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/ifTemplateIntro.txt}
\caption*{а) Шаблон для оператора ветвления}    
\end{minipage}\hfill
\begin{minipage}{.25\textwidth}
    \lstinputlisting[language=Java]{codes/ifCodeIntro.txt}
\caption*{б) Результат применения шаблона}    
\end{minipage}
\caption{Оператор ветвления и шаблон для него}    
\label{fig:tmpltcodeintro}
\end{figure}

Отличием этого подхода от классических форматеров является то, что вместо
настроек используется \emph{образец} --- репозиторий с кодом, 
удовлетворяющим желаемому СК. Из образца с помощью (не кооперативного)
синтаксического анализатора выделяются шаблоны, которые в последствии
используются для построения представлений для переданных на форматирование
программ.
Подобные форматеры мы будем называть \emph{декларативными}.

%% В статье \cite{while} был рассмотрен метод создания форматеров для различных
%% языков программирования, которые настраиваются на требуемый СК по образцу
%% кода, а в качестве апробации разработаны декларативные форматеры для языков
%% Java, Haskell~\cite{korDiploma} и учебного языка While.
%% Выбор языка Java обусловлен тем, что C-подобный синтаксис очень
%% распространен, а значит, метод, применимый для Java, можно распространить
%% и на множество других языков.
%% В Haskell форматирование является неотъемлемой частью языка и влияет
%% на его синтаксическую корректность. 
%% Применимость метода к таким разным языкам показывает, что метод
%% адекватен и может быть использован и для других языков
%% программирования.

%Эти форматеры генерировались по специальному XML-описанию конструкций языка (одна конструкция~--- один файл с описанием). 
Декларативный форматер из [1] %\cite{while}
реализован как плагин для
IntelliJ IDEA. В текущем состоянии системы для 
получения форматера нового языка необходимо вручную задать описание
синтаксических структур этого языка.
Оно задается в виде XML-файла для каждой конструкции языка,
по которому генерируется необходимый код.
В это описание входят название структуры, класс синтаксического анализатора
в платформе IntelliJ IDEA, список поддеревьев.
Для оператора ветвления такое описание имеет следующий вид:

\lstinputlisting[language=c]{codes/whileXml.txt}

\noindent
Поскольку количество конструкций в языке может быть достаточно большим,
создание такого описания для каждой компоненты языка весьма трудоёмко.

%Недостатком такого подхода является то, что в языке может быть большое количество конструкций (While~--- около двадцати, Erlang~--- более ста).

Как уже было замечено, для декларативного форматера требуется наличие
синтаксического анализатора целевого языка.
Если поддержка целевого языка ещё не реализована для платформы
IntelliJ IDEA, необходимо разработать соответствующий анализатор.
Сделать это можно с помощью плагина
Grammar-Kit\footnote{\texttt{https://github.com/JetBrains/Grammar-Kit}}
путем генерации анализатора по грамматике в форме Бэкуса-Наура.
Стоит заметить, что грамматика языка несёт практически всю информацию,
которую нужно заносить в упомянутое ранее XML-описание конструкций.
Таким обзразом, по БНФ-грамматике языка наряду с синтаксическим и
лексическим анализаторами можно автоматически получать и форматер
для этого языка программирования.

Целью данной работы является описание метода генерации декларативных
принтеров по грамматике языка в форме Бэкуса-Наура,интеграции этого метода
в плагин Grammar-Kit и апробации этого метода на примере учебного языка
While.

\section{Обзор}
Существует достаточно много различных подходов к форматированию
программного кода.
Наиболее близкий к нашей работе метод описан в[2]
%~\cite{Brand-Visser:ACM96}.
В этой работе форматер может быть получен по ASF+SDF [3]
%~\cite{Klint:ACM93}
описанию языка, которое представляет собой проаннотированную грамматику.
Форматер получается путём 
рассмотрения продукций грамматики как правил форматирования
с применением нескольких эвристик,
почерпнутых из стандартов форматирования Algol-подобных языков.
%% Причём для полученного форматера тривиальным образом верно, что он
%% порождает программный текст, который соответствует грамматике языка.
%% Разработчик, использующий описываемую систему, также может вручную поменять
%% часть правил форматирования.
Недостатком является то, что правила форматирования ``зашиты'' в
описание грамматики, и могут быть модифицированы только разработчиком
форматера,
в отличие от подхода с использованием синтаксических шаблонов,
позволяющего пользователю декларативным образом настраивать форматер.
%% , но с потерей последнего свойства.

Как было отмечено во введении, широко распространены и используемы
форматеры, встроенные в IDE.
Они используют десятки настроек форматирования,
которые не являются формальными производными грамматики языка,
а выбираются разработчиком форматера на основании его представлений
о возможных и используемых на практике СК для целевого языка.
Сильными сторонами таких форматеров являются тесная интеграция
со средой разработки и то, что их выразительности достаточно в
большинстве случаев.
При этом они не лишены недостатков:
для поддержки нового языка
необходимо определить нужный набор настроек, а также вручную реализовать
форматер;
если пользователю необходимо, чтобы форматер соблюдал стандарт
форматирования некоторой существующей кодовой базы, то он должен
самостоятельно определить значения настроек
в соответствии с этой кодовой базой.
Последний недостаток решается
работами [4,5], %~\cite{Corbo-al:ICSM07,JB-Gen},
которые предоставляют
способы автоматического вычленения настроек форматирования из программного
кода.

\section{Генерация декларативных форматеров}
Для генерации декларативных принтеров будет использоваться БНФ-грамматика, по которой генерируются синтаксический и лексический анализатор соответствующими генераторами в плагине Grammar-Kit.
Наша цель изменить грамматику таким образом, чтобы из нее можно было извлечь все необходимые данные для генерации декларативных форматеров.
\subsection{Изменения в грамматике}
Помимо описания синтаксиса языка, грамматика содержит некоторые дополнительные данные, необходимые генератору синтаксического анализатора.
Среди этих данных, например, будущие зависимости классов, Java-пакеты, префиксы и суффикcы сгенерированных классов и др.

\subsubsection*{Генерация компонент форматера для списковых структур}
\emph{Компонентой} форматера является класс, описывающий, каким образом должна форматироваться данная структура языка.
В работе [1] %~\cite{while}
описываются особенности форматирования списковых структур языка.
Поэтому заранее необходимо знать, является ли структура списком, чтобы сгенерировать для нее корректную компоненту.
В связи с этим появилась необходимость в дополнительном обозначении таких структур.
Если правило описывает некоторую списочную конструкцию, то дополнительно указывается модификатор \emph{list}.
Это позволяет явно указать шаблон для их генерации.

\subsubsection*{Генерация файловой компоненты}
Каждая сгенерированная компонента форматера использует соответствующий Psi-класс (``\emph{Psi}''~--- стандартный префикс классов синтаксических узлов в платформе IntelliJ IDEA).
Файловая компонента не является исключением, однако генератор синтаксического анализатора не генерирует соответствующий Psi-узел, и поэтому он всегда создается вручную.
Способ создания такого класса не подчиняется строгим правилам и может иметь вариации, поэтому возникает множество трудностей при генерации (разное количество поддеревьев, которое можно получить с помощью генератора и которое предоставляется Psi-узлом; несоответствие имен методов и др.).
Решением этой проблемы стало явное задание поддеревьев, которые будут сгенерированы.
Например, поддеревья языка Java можно задать следующим образом: \lstinline[language=java]{fileSubtrees="PackageStatement, ImportList, Classes*"}.
Названия поддеревьев соответствуют методам Psi-узла, ``*'' указывает, что поддерево является массивом или списком.


\subsection{Выделение значимых элементов}
Первое, что необходимо сделать~--- выделить значимые элементы языка. 
Под \emph{значимыми} понимаются элементы, которым потенциально нужно будет менять форматирование.
Помимо описанного выше модификатора для списков, у правил есть и другие модификаторы.
Среди них: private, external~--- для таких правил не генерируются компоненты форматера исходя из тех соображений, что и генератор синтаксического анализатора не создает для них Psi-узлов .
Правило с отличными от указанных выше модификаторами считается значимым при выполнении следующих условий: оно не является цепным или леворекурсивным.

\subsection{Определение поддеревьев}
После того, как определены все значимые структуры языка, необходимо понять, из каких подструктур они состоят.
Используя XML-описания, мы могли явно указывать поддеревья для какой-либо компоненты.
Теперь же всю информацию о поддеревьях можно получить прямо из правила грамматики.
\emph{Поддеревом} в контексте данной работы будет являться терминал или значимый нетерминал в правой части правила.

\subsection{Генерация}
После определения значимых правил и их поддеревьев происходит генерация кода компонент языка.

Так как компоненты принципиально мало отличаются друг от друга, то для генерации можно использовать файлы-шаблоны, в которых существует множество меток вида \lstinline[language=java]{@TEXT@} для вставки соответствующей информации.
На рис.~\ref{component} изображен шаблон для генерации компоненты форматера.
\begin{figure}[h]
	\centering
	\lstinputlisting[language=java]{codes/component.txt}
	\caption{Шаблон для генерации компонент}
	\label{component}
\end{figure}

\section{Апробация}
На рис.~\ref{whileBnf} изображена часть итоговой грамматики языка While.
Она подается на вход генератору принтера, который автоматически сгенерирует форматер и его компоненты.
По этой грамматике генерируется 19 компонент (в общем, 2200 строк кода).
Этого количества достаточно для форматирования программ, написанных на этой языке.

\begin{figure}[h]
	\centering
	\lstinputlisting[language=xml]{codes/whileBnf.txt}
	\caption{Часть БНФ-грамматики языка While}
	\label{whileBnf}
\end{figure}

\subsection{Пример работы декларативного форматера для языка While}
Рассмотрим программу на языке While (см. рис.~\ref{whileProg}).
На рис.~\ref{whileTs} приведены программы, которые будут
использованы для форматирования кода с рис.~\ref{whileProg}.
Результаты форматирования приведены на рис.~\ref{whileRes}.
Полученный код является синтаксически корректным и имеет то же форматирование, что переданный на вход шаблон.

\begin{figure}[h]
	\centering
	\lstinputlisting[language=xml]{codes/whileProg.txt}
	\caption{Пример программы на языке While}
	\label{whileProg}
\end{figure}

\fvset{frame=lines,framesep=6pt}
\begin{figure}[ht]
\noindent\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileT1.txt}
\caption*{а)}    
\end{minipage}\hfill
\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileT2.txt}
\caption*{б)}    
\end{minipage}
\caption{Образцы форматирования}    
\label{whileTs}
\end{figure}

\fvset{frame=lines,framesep=6pt}
\begin{figure}[ht]
\noindent\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileRes1.txt}
\caption*{а)}    
\end{minipage}\hfill
\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileRes2.txt}
\caption*{б)}    
\end{minipage}
\caption{Результат форматирования программы из рис.~\ref{whileProg}}
\label{whileRes}
\end{figure}

\section{Заключение}
В рамках исследования была разработана методика генерации декларативных
форматеров по грамматике в форме Бэкуса-Наура.
Соответствующая функциональность реализована как расширение плагина
Grammar-Kit для среды разработки IntelliJ IDEA.
Корректность работы была проверена на примере генерации форматера
учебного языка While.

Несмотря на то, что представляемая реализация может быть использована
лишь в рамках платформы IntelliJ IDEA,
основные идеи, на которых она базируется,
могут быть переиспользованы и в других окружениях.

%% Ограничением данного подхода является необходимость наличия грамматики
%% языка в форме, понятной плагину Grammar-Kit. 
%% Если же грамматика уже существует, то необходимо вручную найти в ней правила для списочных структур и отметить их модификатором \emph{list}.
%% Кроме того, платформа для поддержки новых языков в IntelliJ IDEA подразумевает наличие фабрики элементов, преобразующей программный текст структур языка в объекты, которыми оперирует система.
%% Если форматер разрабатывается для языка, поддержки которого ранее не было, то фабрику элементов можно сгенерировать или написать вручную понятным для форматера образом.
%% В случае, если форматер генерируется для языка, для которого уже есть поддержка в системе (а значит, есть и фабрика элементов), то необходимо создать посредника между ними для обеспечения взаимодействия.

% use section* for acknowledgment
\section*{Благодарности}
Работа выполнена при поддержке компании JetBrains\footnote{https://jetbrains.com}, в рамках совместной с СПбГУ лаборатории языковых инструментов.

% references section
\nocite{*}

%% \printbibliography
%% \bibliographystyle{abbrv}
%% \bibliography{seim}

\begin{thebibliography}{4}

%% \bibitem{korDiploma}
%%   А. Коровянский. Абстрактная печать по образцу
%%   // Дипломная работа, МатМех СПбГУ, 2015.

\bibitem{while}
  А. Подкопаев, А. Коровянский, И. Озерных.
  Языконезависимое форматирование текстов программ
  на основе сопоставления с образцом и синтаксических шаблонов
  // НТВ СПбГПУ 4' (224), 2015.

%% \bibitem{podkopaevDiploma}
%%   А. Подкопаев. Полиномиальной сложности оптимальные принтер-комбинаторы с выбором
%%   // Дипломная работа, МатМех СПбГУ, 2014.
  
%% \bibitem{maintenance}
%%   G. Alkhatib.
%%   The maintenance problem of application software:
%% an empirical analysis //
%%   Journal of Software Maintenance, 4(2):83–104, 1992.
  
\bibitem{Brand-Visser:ACM96} M. van den Brand and E. Visser.
Generation of formatters for context-free languages //
ACM Trans. Softw. Eng. Meth. 5, 1, p1-41, 1996.

\bibitem{Klint:ACM93} P. Klint. A Meta-environment for Generating Programming Environments //
ACM Trans. Softw. Eng. Meth. 2, 2, p176-201, 1993.

\bibitem{Corbo-al:ICSM07} F. Corbo, C. Del Grosso, M.Di Penta.
Smart Formatter: Learning Coding Style from Existing Source Code //
ICSM. 2007.

\bibitem{JB-Gen} A.Kazakova.
Applying Genetic Algorithms to Automatic Code Formatting
// \texttt{https://blog.jetbrains.com/clion/2015/11/applying-genetic-algorithms-to-automatic-code-formatting/}
\emph{(last visited 17 Apr 2016)}
\end{thebibliography}

\end{document}

