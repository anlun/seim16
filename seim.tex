%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************
\documentclass[conference]{IEEEtran}
\input{preamble}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{verbments}
\usepackage{minted}
\usepackage{caption}
\usepackage{fancybox}
%% \usepackage{cite}
\newfontfamily{\cyrillicfonttt}{DejaVu Serif}

\makeatletter
\define@key{blx@lbx}{fromjapanese}{\blx@defstring{fromjapanese}{#1}}
\define@key{blx@lbx}{langjapanese}{\blx@defstring{langjapanese}{#1}}
\makeatother

\lstset{
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=~,
language=java
}

%% Bibliography file
%% \addbibresource{seim.bib}


% If you need to correct hyphenations, add them here
\hyphenation{op-tical net-works semi-conduc-tor}

\newcommand{\igo}[1]{{\color{red}({Игорь:\ #1})}\marginpar{$\checkmark$}}
\newcommand{\app}[1]{{\color{blue}({Антон:\ #1})}\marginpar{$\checkmark$}}

\begin{document}
%
% paper title
%
% In English titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Генерация декларативных форматтеров по грамматике в форме Бэкуса-Наура}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{\IEEEauthorblockN{Игорь Озерных}
\IEEEauthorblockA{Санкт-Петербургский\\Государственный Университет\\
st011628@student.spbu.ru}
\and
\IEEEauthorblockN{Антон Подкопаев}
\IEEEauthorblockA{Санкт-Петербургский\\Государственный Университет\\
a.podkopaev@2009.spbu.ru}
}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}


Аккуратное форматирование программных текстов желательно для облегчения их восприятия. 
% * <podkoav239@gmail.com> 23:10:11 15 Apr 2016 UTC+0300:
% Фраза очень корявая. Нужно переписать.
Существуют различные 
%средства автоматического 
подходы к форматирования кода. 
Одним из них является форматирование на основе синтаксических шаблонов. 
Оно позволяет задавать стиль форматирования с помощью образца кода. % фразу переделать?
Для апробации этого способа был создан принтер-плагин%
\cite{podkopaevDiploma} для интегрированной среды разработки IntelliJ IDEA.
% * <podkoav239@gmail.com> 23:20:29 15 Apr 2016 UTC+0300:
% Убрать ссылки из аннотации.

Поддержка новых языков в этом плагине осуществляется путем создания описания всех конструкций добавляемого языка.
Такой подход является довольно трудоемким из-за потенциально большого количества конструкций в новом языке.
Целью данной работы является создание методики генерации декларативного форматтера на основе грамматики языка в форме Бэкуса-Наура.

Полученная методика была апробирована на примере учебного языка While: сгенерирован и протестирован принтер-плагин, позволяющий форматировать исходный текст программ на этом языке. 
\end{abstract}
% * <podkoav239@gmail.com> 23:36:32 15 Apr 2016 UTC+0300:
% Аннотацию нужно полностью переписать.
% В ней нужно сказать, что задача форматирования важна. Что существует подход форматирования по синтаксическим шаблонам, у которого недостаток --- он требует много лишнего описывать.
% Дальше -- что нового предлагает данная работа, результаты апробации.

\section{Введение}
% наверное, надо переписать это, так как более новых данных я не нашел про 80%
%Этап поддержки и сопровождения в жизненном цикле программного обеспечения может занимать до 80\%\cite{maintenance} времени существования продукта. 
Этап поддержки и сопровождения является неотъемлмой частью в жизненном цикле программного обеспечения. %?
На этом этапе особенно важным является понимание программного текста поддерживаемой системы. 
% * <podkoav239@gmail.com> 23:37:26 15 Apr 2016 UTC+0300:
% Предыдущие 2 предложения не нужны.
Для этого необходимо сделать код легко читаемым, то есть форматировать его.
Форматирование каких элементов необходимо произвести и каким образом определяется стандартом кодирования (CK, coding convention).
Например, для языка программирования C++ наиболее популярными являются следующие стандарты кодирования: Google\footnote{\texttt{https://google-styleguide.googlecode.com/svn/trunk/cppguide.html}}, GNU\footnote{\texttt{http://www.gnu.org/prep/standards/standards.html}}, BSD\footnote{\texttt{https://www.freebsd.org/cgi/man.cgi?query=style\&sektion=9}}.

Существуют различные подходы к форматированию кода. Одним из них является использование форматтеров (программ, форматирующих код).
Современные интегрированные среды разработки (IDE), такие как IntelliJ IDEA, Visual Studio, Eclipse и др.,~--- включают в себя форматтеры.
Желаемый стиль кодирования задается с помощью множества настроек. Например, расположение открывающей фигурной скобки (на той же строке или на новой), количество пробелов в отступе (для операторов внутри фигурных скобок) и т.д.

Недостатком этого подхода является необходимость вручную задавать настройки форматирования, что может быть неудобным при переходе от одного СК к другому.
Кроме того, количество принципиально разных стилей форматирования, которых можно задать с помощью данных настроек, невелико.
Например, настройки форматтеров приведенных IDE не позволяют выразить СК, в котором закрывающая фигурная скобка ставится на той же строке, что и последний оператор блока (см. рис.~\ref{fig:unusualCC}).
\begin{figure}[h]
	\centering
	\lstinputlisting[language=c]{codes/unusualCC.txt}
	\caption{Нестандартный СК}
	\label{fig:unusualCC}
\end{figure}

Альтернативный подход к форматированию описан в статье~\cite{while} и основывается на сопоставлении с образцом и синтаксических шаблонах.
Под \emph{шаблоном} понимаются данные, сопоставление которых с элементом синтаксического дерева дает текстовое представление этого элемента.

Например, на рис.~\ref{fig:ifTree} представлено дерево разбора для оператора ветвления. 
\begin{figure}[h]
	\centering
	\includegraphics[width=.5\textwidth]{images/ifTree.jpg}
	\caption{Представление оператора ветвления в виде дерева разбора}
	\label{fig:ifTree}
\end{figure}

На рис.~\ref{fig:tmpltcodeintro}а изображен шаблон форматирования, который может быть применен к нему (несколько подвыражений, соответствующих выполнению условия, и одно подвыражение, соответствующее невыполненению условия).
На рис.~\ref{fig:tmpltcodeintro}б представлен результат применения этого шаблона к дереву разбора для оператора ветвления.

\fvset{frame=lines,framesep=6pt}
\begin{figure}[ht]
\noindent\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/ifTemplateIntro.txt}
\caption*{а) Шаблон для оператора ветвления}    
\end{minipage}\hfill
\begin{minipage}{.25\textwidth}
    \lstinputlisting[language=Java]{codes/ifCodeIntro.txt}
\caption*{б) Текст, полученный при применении шаблона к дереву разбора}    
\end{minipage}
\caption{Оператор ветвления и шаблон для него}    
\label{fig:tmpltcodeintro}
\end{figure}

Отличием этого подхода от классических форматтеров является то, что вместо настроек используется репозиторий, содержащий код с желаемым форматированием.
Подобные форматтеры мы будем называть \emph{декларативными}.
Декларативность достигается путем вычленения из образца синтаксических шаблонов для конструкций целевого языка и построения с их помощью представлений для переданных на форматирование программ.

В статье был рассмотрен метод создания форматтеров для различных языков программирования, которые настраиваются на требуемый СК по образцу кода, а в качестве апробации разработаны декларативные форматтеры для языков Java, Haskell и учебного языка While.
Эти форматтеры генерировались по специальному XML-описанию конструкций языка (одна конструкция~--- один файл с описанием). 
Недостатком такого подхода является то, что в языке может быть большое количество конструкций (While~--- около двадцати, Erlang~--- более ста).
В связи с этим, создание такого описания компонент языка может быть весьма трудоемким.

В статье~\cite{while} указывается на то, что для языков, не имеющих поддержки со стороны IntelliJ IDEA, необходимо сначала получить синтаксический и лексический анализаторы.
Сделать это можно с помощью плагина GrammarKit\footnote{\texttt{https://github.com/JetBrains/Grammar-Kit}} путем их генерации по грамматике в форме Бэкуса-Наура.
Для уменьшения трудозатрат по созданию декларативного форматтера можно использовать те же входные данные, что используются для генерации анализаторов, то есть грамматику языка.

Целью данной работы является описание метода генерации декларативных принтеров по грамматике языка в форме Бэкуса-Наура и апробации этого метода на примере учебного языка While.


\section{Обзор}


\section{Генерация декларативных форматтеров}
\subsection{Изменение в грамматике}
Грамматика языка подверглась небольшому изменению.
В связи с особенностями форматирования списочных конструкций~\cite{while} и их неотличимостью от ``обычных'' с точки зрения грамматики появилась необходимость в их дополнительном обозначении. 
Если правило описывает некоторую списочную конструкцию, то дополнительно указывается модификатор \emph{list}.
Это позволяет явно указать шаблон для их генерации.

\subsection{Выделение значимых элементов}
Первое, что необходимо сделать~--- выделить значимые элементы языка. 
Под \emph{значимыми} понимаются элементы, которым потенциально нужно будет менять форматирование.
Помимо описанного выше модификатора для списков, у правил есть и другие модификаторы.
Среди них: private, external~--- для таких правил не генерируются компоненты форматтера исходя из тех соображений, что и генератор синтаксического анализатора не создает для них Psi-узлов (``\emph{Psi}''~--- стандартный префикс классов синтаксических узлов в платформе IntelliJ IDEA).
Правило с отличными от указанных выше модификаторами считается значимым при выполнении следующих условий: оно не является цепным или леворекурсивным.

\subsection{Определение поддеревьев}
После того, как определены все значимые структуры языка, необходимо понять, из каких подструктур они состоят.
Используя XML-описания~\cite{while}, мы могли явно указывать поддеревья для какой-либо компоненты.
Теперь же всю информацию о поддеревьях можно получить прямо из правила грамматики.
Поддеревом в контексте данной работы будет являться терминал или значимый нетерминал в правой части правила.

\subsection{Генерация}
После определения значимых правил и их поддеревьев происходит генерация кода компонент языка.
Так как компоненты принципиально мало отличаются друг от друга, то для генерации можно использовать файлы-шаблоны, в которых существует множество меток вида \lstinline[language=java]{@TEXT@} для вставки соответствующей информации.
На рис.~\ref{component} изображен шаблон для генерации компоненты форматтера.
\begin{figure}[h]
	\centering
	\lstinputlisting[language=java]{codes/component.txt}
	\caption{Шаблон для генерации компонент}
	\label{component}
\end{figure}

\section{Апробация}
На рис.~\ref{whileBnf} изображена часть итоговой грамматики языка While.
По этой грамматике генерируется 19 компонент (в общем, 2200 строк кода).
Этого количества достаточно для форматирования программ, написанных на этой языке.

\begin{figure}[h]
	\centering
	\lstinputlisting[language=xml]{codes/whileBnf.txt}
	\caption{Грамматика языка While в форме Бэкуса-Наура}
	\label{whileBnf}
\end{figure}

\subsection{Пример работы декларативного форматтера для языка While}
Рассмотрим программу на языке While (см. листинг~\ref{whileProg}).
На листингах~\ref{whileTs} а и б приведены программы, которые будут использованы для форматирования листинга~\ref{whileProg}.
Результаты форматирования приведены на листинге~\ref{whileRes}.

\begin{figure}[h]
	\centering
	\lstinputlisting[language=xml]{codes/whileProg.txt}
	\caption{Пример программы на языке While}
	\label{whileProg}
\end{figure}

\fvset{frame=lines,framesep=6pt}
\begin{figure}[ht]
\noindent\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileT1.txt}
\caption*{а)}    
\end{minipage}\hfill
\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileT2.txt}
\caption*{б)}    
\end{minipage}
\caption{Образцы форматирования}    
\label{whileTs}
\end{figure}

\fvset{frame=lines,framesep=6pt}
\begin{figure}[ht]
\noindent\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileRes1.txt}
\caption*{а)}    
\end{minipage}\hfill
\begin{minipage}{.2\textwidth}
    \lstinputlisting[language=Java]{codes/whileRes2.txt}
\caption*{б)}    
\end{minipage}
\caption{Результат форматирования программы из листинга~\ref{whileProg}}
\label{whileRes}
\end{figure}

\section{Заключение}
В рамках исследования была разработана методика генерации декларативных форматтеров по грамматике в форме Бэкуса-Наура.
Соответствующая функциональность реализована в рамках проекта GrammarKit.
Корректность работы была проверена на примере генерации форматтера учебного языка While.

Ограничением данного подхода является необходимость наличия граммтики языка в форме, понятной плагину GrammarKit. 
Если же грамматика уже существует, то необходимо вручную найти в ней правила для списочных структур и отметить их модификатором \emph{list}.
Кроме того, платформа для поддержки новых языков в IntelliJ IDEA подразумевает наличие фабрики элементов, преобразующей программный текст структур языка в объекты, которыми оперирует система.
Если форматтер разрабатывется для языка, поддержки которого ранее не было, то фабрику элементов можно сгенерировать или напистать вручную понятным для форматтера образом.
В случае, если форматтер генерируется для языка, для которого уже есть поддержка в системе (а значит, есть и фабрика элементов), то необходимо создать посредника между ними для обеспечения взаимодействия.

% use section* for acknowledgment
% \section*{Благодарность}
Работа выполнена при поддержке компании JetBrains\footnote{https://jetbrains.com}.

% references section
\nocite{*}

\begin{thebibliography}{4}

\bibitem{while}
  А.Подкопаев, А.Коровянский, И.Озерных.
  Языконезависимое форматирование текстов программ
  на основе сопоставления с образцом и синтаксических шаблонов
  // НТВ СПбГПУ 4' (224), 2015.

\bibitem{podkopaevDiploma}
  А.Подкопаев. Полиномиальной сложности оптимальные принтер-комбинаторы с выбором
  // Дипломная работа, МатМех СПбГУ, 2014.

\bibitem{maintenance}
  G.Alkhatib.
  The maintenance problem of application software:
an empirical analysis //
  Journal of Software Maintenance, 4(2):83–104, 1992.

\end{thebibliography}

\end{document}
